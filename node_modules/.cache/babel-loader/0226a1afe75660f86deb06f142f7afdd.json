{"ast":null,"code":"import { randomSample, distance } from '../utils';\nimport { AGENT, SUSCEPTIBLE, SICK, DEAD } from '../constants';\nimport { getNextMarkovStateForAgent, STAY, BASE, applySIRModel } from './markov';\nimport { applyFixedNodeGrid } from './grid';\nconst VENUES = [{\n  name: 'house',\n  members: simulationState => simulationState.agentsPerHouse,\n  isRoot: true,\n  count: simulationState => simulationState.houses\n}, {\n  name: 'school',\n  count: simulationState => simulationState.schools\n}, {\n  name: 'hospital',\n  count: simulationState => simulationState.hospitals\n}, {\n  name: 'supermarket',\n  count: simulationState => simulationState.supermarkets\n}, {\n  name: 'station',\n  count: simulationState => simulationState.busStations\n}];\nconst VENUE_TRANSITIONS = {\n  'house': ['supermarket', 'station', 'hospital', 'house', 'house', 'house', 'house', 'house', 'house', 'house', 'house'],\n  'supermarket': ['base', 'base', 'base', 'supermarket'],\n  'hospital': ['hospital', 'base', 'base', 'base'],\n  'station': ['supermarket', 'base', 'base', 'base', 'school'],\n  'school': ['supermarket', 'base', 'base', 'base']\n};\n\nfunction getInitialGraph(simulationState) {\n  const nodes = [];\n  const edges = [];\n  VENUES.forEach(({\n    name,\n    members,\n    isRoot,\n    count,\n    alignment\n  }) => {\n    for (let i = 0, nodeIndex = 0; i < count(simulationState); i++, nodeIndex++) {\n      const venueId = `${name}-${i}`;\n      const venueIndex = nodeIndex;\n      nodes.push({\n        type: 'venue',\n        venue: name,\n        id: venueId,\n        size: 1\n      });\n\n      if (!members) {\n        continue;\n      }\n\n      for (var j = 0; j < members(simulationState); j++, nodeIndex++) {\n        const agentId = `${name}-${i}-${j}`;\n        nodes.push({\n          type: 'agent',\n          location: venueId,\n          base: venueId,\n          id: agentId,\n          size: 1,\n          state: SUSCEPTIBLE\n        });\n        edges.push({\n          'source': agentId,\n          'target': venueId\n        });\n      }\n    }\n  });\n  const sickAgents = randomSample(nodes.filter(({\n    type\n  }) => type === 'agent'), simulationState.initialSickAgents);\n\n  for (const agent of sickAgents) {\n    agent.state = SICK;\n  }\n\n  return {\n    nodes: applyFixedNodeGrid(nodes),\n    edges\n  };\n}\n\nfunction nextSimulationTick(state, nodes, edges) {\n  const rootVenue = VENUES.find(({\n    isRoot\n  }) => isRoot);\n  nodes.filter(({\n    type\n  }) => type === AGENT).forEach((agent, i) => {\n    const nextMarkovState = getNextMarkovStateForAgent(agent, VENUE_TRANSITIONS);\n    const [agentLocation] = agent.location.split('-');\n\n    if (agentLocation === nextMarkovState || nextMarkovState === BASE && agent.location === agent.base || nextMarkovState === STAY) {\n      return;\n    } else if (agent.state === DEAD) {\n      return;\n    } else if (nextMarkovState === BASE) {\n      moveAgent(nodes, edges, agent, nodes.find(({\n        id\n      }) => id === agent.base));\n    } else {\n      moveAgent(nodes, edges, agent, findClosestNode(agent, nodes.filter(({\n        venue\n      }) => venue === nextMarkovState)));\n    }\n\n    ;\n  });\n  nodes = applySIRModel(nodes, edges);\n  return {\n    nodes: nodes,\n    edges: edges,\n    state: { ...state,\n      tick: state.tick + 1\n    }\n  };\n}\n\nfunction moveAgent(nodes, edges, agent, targetNode) {\n  const sourceNode = nodes.find(({\n    id\n  }) => id === agent.location);\n\n  if (targetNode.locked || sourceNode.locked) {\n    return;\n  }\n\n  const newEdges = edges.map(edge => {\n    if (edge.source.id === agent.id) {\n      edge.target = targetNode;\n    }\n  });\n  agent.location = targetNode.id;\n}\n\nfunction findClosestNode(source, targets) {\n  const closest = targets.reduce((prev, current) => distance(source, current) < distance(source, prev) ? current : prev);\n  return closest;\n}\n\nexport { VENUES, VENUE_TRANSITIONS, getInitialGraph, nextSimulationTick };","map":{"version":3,"sources":["/Users/rohitrajan/Rohit/projects/coronavirus-simulation/src/simulation/index.js"],"names":["randomSample","distance","AGENT","SUSCEPTIBLE","SICK","DEAD","getNextMarkovStateForAgent","STAY","BASE","applySIRModel","applyFixedNodeGrid","VENUES","name","members","simulationState","agentsPerHouse","isRoot","count","houses","schools","hospitals","supermarkets","busStations","VENUE_TRANSITIONS","getInitialGraph","nodes","edges","forEach","alignment","i","nodeIndex","venueId","venueIndex","push","type","venue","id","size","j","agentId","location","base","state","sickAgents","filter","initialSickAgents","agent","nextSimulationTick","rootVenue","find","nextMarkovState","agentLocation","split","moveAgent","findClosestNode","tick","targetNode","sourceNode","locked","newEdges","map","edge","source","target","targets","closest","reduce","prev","current"],"mappings":"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","sourcesContent":["import { randomSample, distance } from '../utils';\n\nimport { AGENT, SUSCEPTIBLE, SICK, DEAD } from '../constants';\n\nimport { getNextMarkovStateForAgent, STAY, BASE, applySIRModel } from './markov';\nimport { applyFixedNodeGrid } from './grid';\n\nconst VENUES = [\n  {\n    name: 'house',\n    members: simulationState => simulationState.agentsPerHouse,\n    isRoot: true,\n    count: simulationState => simulationState.houses,\n  },\n  {\n    name: 'school',\n    count: simulationState => simulationState.schools,\n  },\n  {\n    name: 'hospital',\n    count: simulationState => simulationState.hospitals,\n  },\n  {\n    name: 'supermarket',\n    count: simulationState => simulationState.supermarkets,\n  },\n  {\n    name: 'station',\n    count: simulationState => simulationState.busStations,\n  },\n];\n\nconst VENUE_TRANSITIONS = {\n  'house': ['supermarket', 'station', 'hospital', 'house', 'house', 'house',\n            'house', 'house', 'house', 'house', 'house'],\n  'supermarket': ['base', 'base', 'base', 'supermarket'],\n  'hospital': ['hospital', 'base', 'base', 'base'],\n  'station': ['supermarket', 'base', 'base', 'base', 'school'],\n  'school': ['supermarket', 'base', 'base', 'base'],\n};\n\nfunction getInitialGraph(simulationState) {\n  const nodes = [];\n  const edges = [];\n\n  VENUES.forEach(({\n    name,\n    members,\n    isRoot,\n    count,\n    alignment,\n  }) => {\n    for (let i = 0, nodeIndex = 0; i < count(simulationState); i++, nodeIndex++) {\n      const venueId = `${name}-${i}`;\n      const venueIndex = nodeIndex;\n      nodes.push({\n        type: 'venue',\n        venue: name,\n        id: venueId,\n        size: 1,\n      });\n\n      if (!members) {\n        continue;\n      }\n\n      for (var j = 0; j < members(simulationState); j++, nodeIndex++) {\n        const agentId = `${name}-${i}-${j}`;\n        nodes.push({\n          type: 'agent',\n          location: venueId,\n          base: venueId,\n          id: agentId,\n          size: 1,\n          state: SUSCEPTIBLE,\n        });\n        edges.push({\n          'source': agentId,\n          'target': venueId,\n        });\n      }\n    }\n  });\n\n  const sickAgents = randomSample(\n    nodes.filter(({ type }) => type === 'agent'),\n    simulationState.initialSickAgents\n  );\n\n  for (const agent of sickAgents) {\n    agent.state = SICK;\n  }\n\n  return ({\n    nodes: applyFixedNodeGrid(nodes),\n    edges,\n  });\n}\n\nfunction nextSimulationTick(state, nodes, edges) {\n  const rootVenue = VENUES.find(({ isRoot }) => isRoot);\n\n  nodes\n    .filter(\n      ({ type }) => type === AGENT\n    )\n    .forEach(\n      (agent, i) => {\n        const nextMarkovState = getNextMarkovStateForAgent(agent, VENUE_TRANSITIONS);\n        const [agentLocation] = agent.location.split('-')\n\n        if (\n          agentLocation === nextMarkovState ||\n          (nextMarkovState === BASE && agent.location === agent.base) ||\n          nextMarkovState === STAY\n        ) {\n          return;\n        } else if (agent.state === DEAD) {\n          return;\n        } else if (nextMarkovState === BASE) {\n          moveAgent(\n            nodes,\n            edges,\n            agent,\n            nodes.find(({ id }) => id === agent.base)\n          );\n        } else {\n          moveAgent(\n            nodes,\n            edges,\n            agent,\n            findClosestNode(agent, nodes.filter(({ venue }) => venue === nextMarkovState))\n          );\n        };\n\n      }\n    );\n\n\n  nodes = applySIRModel(nodes, edges);\n\n  return {\n    nodes: nodes,\n    edges: edges,\n    state: { ...state, tick: state.tick + 1},\n  }\n}\n\nfunction moveAgent(nodes, edges, agent, targetNode) {\n  const sourceNode = nodes.find(({ id }) => id === agent.location);\n\n  if (targetNode.locked || sourceNode.locked) {\n    return;\n  }\n\n  const newEdges = edges.map((edge) => {\n    if (edge.source.id === agent.id) {\n      edge.target = targetNode;\n    }\n  });\n\n  agent.location = targetNode.id;\n}\n\nfunction findClosestNode(source, targets) {\n  const closest = targets.reduce(\n    (prev, current) => distance(source, current) < distance(source, prev) ? current : prev\n  );\n\n  return closest;\n}\n\nexport {\n  VENUES,\n  VENUE_TRANSITIONS,\n  getInitialGraph,\n  nextSimulationTick,\n};\n"]},"metadata":{},"sourceType":"module"}