{"ast":null,"code":"import _objectSpread from\"/Users/rohitrajan/Rohit/projects/coronasim/react-coronasim/home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/rohitrajan/Rohit/projects/coronasim/react-coronasim/home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _createForOfIteratorHelper from\"/Users/rohitrajan/Rohit/projects/coronasim/react-coronasim/home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";/* eslint-disable */import{randomSample,distance}from'../utils';import{AGENT,SUSCEPTIBLE,SICK,DEAD}from'../constants';import{getNextMarkovStateForAgent,STAY,BASE,applySIRModel}from'./markov';import{applyFixedNodeGrid}from'./grid';var VENUES=[{name:'house',members:function members(simulationState){return simulationState.agentsPerHouse;},isRoot:true,count:function count(simulationState){return simulationState.houses;}},{name:'school',count:function count(simulationState){return simulationState.schools;}},{name:'hospital',count:function count(simulationState){return simulationState.hospitals;}},{name:'supermarket',count:function count(simulationState){return simulationState.supermarkets;}},{name:'station',count:function count(simulationState){return simulationState.busStations;}}];var VENUE_TRANSITIONS={'house':['supermarket','station','hospital','house','house','house','house','house','house','house','house'],'supermarket':['base','base','base','supermarket'],'hospital':['hospital','base','base','base'],'station':['supermarket','base','base','base','school'],'school':['supermarket','base','base','base']};function getInitialGraph(simulationState){var nodes=[];var edges=[];VENUES.forEach(function(_ref){var name=_ref.name,members=_ref.members,isRoot=_ref.isRoot,count=_ref.count,alignment=_ref.alignment;for(var i=0,nodeIndex=0;i<count(simulationState);i++,nodeIndex++){var venueId=\"\".concat(name,\"-\").concat(i);var venueIndex=nodeIndex;nodes.push({type:'venue',venue:name,id:venueId,size:1});if(!members){continue;}for(var j=0;j<members(simulationState);j++,nodeIndex++){var agentId=\"\".concat(name,\"-\").concat(i,\"-\").concat(j);nodes.push({type:'agent',location:venueId,base:venueId,id:agentId,size:1,state:SUSCEPTIBLE});edges.push({'source':agentId,'target':venueId});}}});var sickAgents=randomSample(nodes.filter(function(_ref2){var type=_ref2.type;return type==='agent';}),simulationState.initialSickAgents);var _iterator=_createForOfIteratorHelper(sickAgents),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var agent=_step.value;agent.state=SICK;}}catch(err){_iterator.e(err);}finally{_iterator.f();}return{nodes:applyFixedNodeGrid(nodes),edges:edges};}function nextSimulationTick(state,nodes,edges){var rootVenue=VENUES.find(function(_ref3){var isRoot=_ref3.isRoot;return isRoot;});nodes.filter(function(_ref4){var type=_ref4.type;return type===AGENT;}).forEach(function(agent,i){var nextMarkovState=getNextMarkovStateForAgent(agent,VENUE_TRANSITIONS);var _agent$location$split=agent.location.split('-'),_agent$location$split2=_slicedToArray(_agent$location$split,1),agentLocation=_agent$location$split2[0];if(agentLocation===nextMarkovState||nextMarkovState===BASE&&agent.location===agent.base||nextMarkovState===STAY){return;}else if(agent.state===DEAD){return;}else if(nextMarkovState===BASE){moveAgent(nodes,edges,agent,nodes.find(function(_ref5){var id=_ref5.id;return id===agent.base;}));}else{moveAgent(nodes,edges,agent,findClosestNode(agent,nodes.filter(function(_ref6){var venue=_ref6.venue;return venue===nextMarkovState;})));};});nodes=applySIRModel(nodes,edges);return{nodes:nodes,edges:edges,state:_objectSpread({},state,{tick:state.tick+1})};}function moveAgent(nodes,edges,agent,targetNode){var sourceNode=nodes.find(function(_ref7){var id=_ref7.id;return id===agent.location;});if(targetNode.locked||sourceNode.locked){return;}var newEdges=edges.map(function(edge){if(edge.source.id===agent.id){edge.target=targetNode;}});agent.location=targetNode.id;}function findClosestNode(source,targets){var closest=targets.reduce(function(prev,current){return distance(source,current)<distance(source,prev)?current:prev;});return closest;}export{VENUES,VENUE_TRANSITIONS,getInitialGraph,nextSimulationTick};","map":{"version":3,"sources":["/Users/rohitrajan/Rohit/projects/coronasim/react-coronasim/home/src/simulation/index.js"],"names":["randomSample","distance","AGENT","SUSCEPTIBLE","SICK","DEAD","getNextMarkovStateForAgent","STAY","BASE","applySIRModel","applyFixedNodeGrid","VENUES","name","members","simulationState","agentsPerHouse","isRoot","count","houses","schools","hospitals","supermarkets","busStations","VENUE_TRANSITIONS","getInitialGraph","nodes","edges","forEach","alignment","i","nodeIndex","venueId","venueIndex","push","type","venue","id","size","j","agentId","location","base","state","sickAgents","filter","initialSickAgents","agent","nextSimulationTick","rootVenue","find","nextMarkovState","split","agentLocation","moveAgent","findClosestNode","tick","targetNode","sourceNode","locked","newEdges","map","edge","source","target","targets","closest","reduce","prev","current"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport { randomSample, distance } from '../utils';\n\nimport { AGENT, SUSCEPTIBLE, SICK, DEAD } from '../constants';\n\nimport { getNextMarkovStateForAgent, STAY, BASE, applySIRModel } from './markov';\nimport { applyFixedNodeGrid } from './grid';\n\nconst VENUES = [\n  {\n    name: 'house',\n    members: simulationState => simulationState.agentsPerHouse,\n    isRoot: true,\n    count: simulationState => simulationState.houses,\n  },\n  {\n    name: 'school',\n    count: simulationState => simulationState.schools,\n  },\n  {\n    name: 'hospital',\n    count: simulationState => simulationState.hospitals,\n  },\n  {\n    name: 'supermarket',\n    count: simulationState => simulationState.supermarkets,\n  },\n  {\n    name: 'station',\n    count: simulationState => simulationState.busStations,\n  },\n];\n\nconst VENUE_TRANSITIONS = {\n  'house': ['supermarket', 'station', 'hospital', 'house', 'house', 'house',\n            'house', 'house', 'house', 'house', 'house'],\n  'supermarket': ['base', 'base', 'base', 'supermarket'],\n  'hospital': ['hospital', 'base', 'base', 'base'],\n  'station': ['supermarket', 'base', 'base', 'base', 'school'],\n  'school': ['supermarket', 'base', 'base', 'base'],\n};\n\nfunction getInitialGraph(simulationState) {\n  const nodes = [];\n  const edges = [];\n\n  VENUES.forEach(({\n    name,\n    members,\n    isRoot,\n    count,\n    alignment,\n  }) => {\n    for (let i = 0, nodeIndex = 0; i < count(simulationState); i++, nodeIndex++) {\n      const venueId = `${name}-${i}`;\n      const venueIndex = nodeIndex;\n      nodes.push({\n        type: 'venue',\n        venue: name,\n        id: venueId,\n        size: 1,\n      });\n\n      if (!members) {\n        continue;\n      }\n\n      for (var j = 0; j < members(simulationState); j++, nodeIndex++) {\n        const agentId = `${name}-${i}-${j}`;\n        nodes.push({\n          type: 'agent',\n          location: venueId,\n          base: venueId,\n          id: agentId,\n          size: 1,\n          state: SUSCEPTIBLE,\n        });\n        edges.push({\n          'source': agentId,\n          'target': venueId,\n        });\n      }\n    }\n  });\n\n  const sickAgents = randomSample(\n    nodes.filter(({ type }) => type === 'agent'),\n    simulationState.initialSickAgents\n  );\n\n  for (const agent of sickAgents) {\n    agent.state = SICK;\n  }\n\n  return ({\n    nodes: applyFixedNodeGrid(nodes),\n    edges,\n  });\n}\n\nfunction nextSimulationTick(state, nodes, edges) {\n  const rootVenue = VENUES.find(({ isRoot }) => isRoot);\n\n  nodes\n    .filter(\n      ({ type }) => type === AGENT\n    )\n    .forEach(\n      (agent, i) => {\n        const nextMarkovState = getNextMarkovStateForAgent(agent, VENUE_TRANSITIONS);\n        const [agentLocation] = agent.location.split('-')\n\n        if (\n          agentLocation === nextMarkovState ||\n          (nextMarkovState === BASE && agent.location === agent.base) ||\n          nextMarkovState === STAY\n        ) {\n          return;\n        } else if (agent.state === DEAD) {\n          return;\n        } else if (nextMarkovState === BASE) {\n          moveAgent(\n            nodes,\n            edges,\n            agent,\n            nodes.find(({ id }) => id === agent.base)\n          );\n        } else {\n          moveAgent(\n            nodes,\n            edges,\n            agent,\n            findClosestNode(agent, nodes.filter(({ venue }) => venue === nextMarkovState))\n          );\n        };\n\n      }\n    );\n\n\n  nodes = applySIRModel(nodes, edges);\n\n  return {\n    nodes: nodes,\n    edges: edges,\n    state: { ...state, tick: state.tick + 1},\n  }\n}\n\nfunction moveAgent(nodes, edges, agent, targetNode) {\n  const sourceNode = nodes.find(({ id }) => id === agent.location);\n\n  if (targetNode.locked || sourceNode.locked) {\n    return;\n  }\n\n  const newEdges = edges.map((edge) => {\n    if (edge.source.id === agent.id) {\n      edge.target = targetNode;\n    }\n  });\n\n  agent.location = targetNode.id;\n}\n\nfunction findClosestNode(source, targets) {\n  const closest = targets.reduce(\n    (prev, current) => distance(source, current) < distance(source, prev) ? current : prev\n  );\n\n  return closest;\n}\n\nexport {\n  VENUES,\n  VENUE_TRANSITIONS,\n  getInitialGraph,\n  nextSimulationTick,\n};\n"]},"metadata":{},"sourceType":"module"}