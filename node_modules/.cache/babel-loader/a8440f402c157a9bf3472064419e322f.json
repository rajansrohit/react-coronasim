{"ast":null,"code":"import { SUSCEPTIBLE, SICK, RECOVERED, DEAD } from '../constants';\nimport { randomChoice, weightedRandom } from '../utils';\nexport const STAY = 'stay';\nexport const BASE = 'base';\nconst SIR_TRANSITION_STATE = {\n  [SUSCEPTIBLE]: [[1, SUSCEPTIBLE]],\n  [RECOVERED]: [[1, RECOVERED]],\n  [SICK]: [[0.995, SICK], [0.004, RECOVERED], [0.001, DEAD]],\n  [DEAD]: [[1, DEAD]]\n};\nconst DISEASE_SPREAD_TRANSITION = {\n  [SUSCEPTIBLE]: [[0.3, SICK], [0.7, SUSCEPTIBLE]],\n  [RECOVERED]: [[1, RECOVERED]],\n  [SICK]: [[1, SICK]],\n  [DEAD]: [[1, DEAD]]\n};\nexport function getNextMarkovStateForAgent(agent, transitionMap) {\n  const [agentLocation] = agent.location.split('-');\n\n  if (agentLocation === 'house' && Math.random() < 0.9) {\n    return STAY;\n  }\n\n  const map = transitionMap[agentLocation];\n  return randomChoice(map);\n}\nexport function applySIRModel(nodes, edges) {\n  for (const node of nodes) {\n    if (node.type !== 'agent') {\n      continue;\n    }\n\n    const location = nodes.find(({\n      id\n    }) => node.location === id);\n    const fellows = edges.filter(({\n      target\n    }) => target.id === location.id).map(({\n      source\n    }) => source);\n    fellows.forEach(fellow => {\n      if (fellow.id === node.id) {\n        return;\n      }\n\n      if (node.state === SICK) {\n        fellow.state = weightedRandom(DISEASE_SPREAD_TRANSITION[fellow.state]);\n      }\n\n      fellow.state = weightedRandom(SIR_TRANSITION_STATE[fellow.state]);\n    });\n  }\n}","map":{"version":3,"sources":["/Users/rohitrajan/Rohit/projects/nodejs-coronasim/src/simulation/markov.js"],"names":["SUSCEPTIBLE","SICK","RECOVERED","DEAD","randomChoice","weightedRandom","STAY","BASE","SIR_TRANSITION_STATE","DISEASE_SPREAD_TRANSITION","getNextMarkovStateForAgent","agent","transitionMap","agentLocation","location","split","Math","random","map","applySIRModel","nodes","edges","node","type","find","id","fellows","filter","target","source","forEach","fellow","state"],"mappings":"AAAA,SACEA,WADF,EACeC,IADf,EACqBC,SADrB,EACgCC,IADhC,QAEO,cAFP;AAIA,SAASC,YAAT,EAAuBC,cAAvB,QAA6C,UAA7C;AAEA,OAAO,MAAMC,IAAI,GAAG,MAAb;AACP,OAAO,MAAMC,IAAI,GAAG,MAAb;AAEP,MAAMC,oBAAoB,GAAG;AAC3B,GAACR,WAAD,GAAe,CACb,CAAC,CAAD,EAAIA,WAAJ,CADa,CADY;AAI3B,GAACE,SAAD,GAAa,CACX,CAAC,CAAD,EAAIA,SAAJ,CADW,CAJc;AAO3B,GAACD,IAAD,GAAQ,CACN,CAAC,KAAD,EAAQA,IAAR,CADM,EAEN,CAAC,KAAD,EAAQC,SAAR,CAFM,EAGN,CAAC,KAAD,EAAQC,IAAR,CAHM,CAPmB;AAY3B,GAACA,IAAD,GAAQ,CACN,CAAC,CAAD,EAAIA,IAAJ,CADM;AAZmB,CAA7B;AAiBA,MAAMM,yBAAyB,GAAG;AAChC,GAACT,WAAD,GAAe,CACb,CAAC,GAAD,EAAMC,IAAN,CADa,EAEb,CAAC,GAAD,EAAMD,WAAN,CAFa,CADiB;AAKhC,GAACE,SAAD,GAAa,CACX,CAAC,CAAD,EAAIA,SAAJ,CADW,CALmB;AAQhC,GAACD,IAAD,GAAQ,CACN,CAAC,CAAD,EAAIA,IAAJ,CADM,CARwB;AAWhC,GAACE,IAAD,GAAQ,CACN,CAAC,CAAD,EAAIA,IAAJ,CADM;AAXwB,CAAlC;AAgBA,OAAO,SAASO,0BAAT,CAAoCC,KAApC,EAA2CC,aAA3C,EAA0D;AAC/D,QAAM,CAACC,aAAD,IAAkBF,KAAK,CAACG,QAAN,CAAeC,KAAf,CAAqB,GAArB,CAAxB;;AAEA,MAAIF,aAAa,KAAK,OAAlB,IAA6BG,IAAI,CAACC,MAAL,KAAgB,GAAjD,EAAsD;AACpD,WAAOX,IAAP;AACD;;AAED,QAAMY,GAAG,GAAGN,aAAa,CAACC,aAAD,CAAzB;AAEA,SAAOT,YAAY,CAACc,GAAD,CAAnB;AACD;AAED,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,KAA9B,EAAqC;AAC1C,OAAK,MAAMC,IAAX,IAAmBF,KAAnB,EAA0B;AACxB,QAAIE,IAAI,CAACC,IAAL,KAAc,OAAlB,EAA2B;AACzB;AACD;;AAED,UAAMT,QAAQ,GAAGM,KAAK,CAACI,IAAN,CAAW,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAYH,IAAI,CAACR,QAAL,KAAkBW,EAAzC,CAAjB;AACA,UAAMC,OAAO,GAAGL,KAAK,CAClBM,MADa,CACN,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAgBA,MAAM,CAACH,EAAP,KAAcX,QAAQ,CAACW,EADjC,EAEbP,GAFa,CAET,CAAC;AAAEW,MAAAA;AAAF,KAAD,KAAgBA,MAFP,CAAhB;AAIAH,IAAAA,OAAO,CAACI,OAAR,CACGC,MAAD,IAAY;AACV,UAAIA,MAAM,CAACN,EAAP,KAAcH,IAAI,CAACG,EAAvB,EAA2B;AACzB;AACD;;AAED,UAAIH,IAAI,CAACU,KAAL,KAAe/B,IAAnB,EAAyB;AACvB8B,QAAAA,MAAM,CAACC,KAAP,GAAe3B,cAAc,CAACI,yBAAyB,CAACsB,MAAM,CAACC,KAAR,CAA1B,CAA7B;AACD;;AAEDD,MAAAA,MAAM,CAACC,KAAP,GAAe3B,cAAc,CAACG,oBAAoB,CAACuB,MAAM,CAACC,KAAR,CAArB,CAA7B;AACD,KAXH;AAaD;AACF","sourcesContent":["import {\n  SUSCEPTIBLE, SICK, RECOVERED, DEAD,\n} from '../constants';\n\nimport { randomChoice, weightedRandom } from '../utils';\n\nexport const STAY = 'stay';\nexport const BASE = 'base';\n\nconst SIR_TRANSITION_STATE = {\n  [SUSCEPTIBLE]: [\n    [1, SUSCEPTIBLE],\n  ],\n  [RECOVERED]: [\n    [1, RECOVERED],\n  ],\n  [SICK]: [\n    [0.995, SICK],\n    [0.004, RECOVERED],\n    [0.001, DEAD],\n  ],\n  [DEAD]: [\n    [1, DEAD],\n  ],\n};\n\nconst DISEASE_SPREAD_TRANSITION = {\n  [SUSCEPTIBLE]: [\n    [0.3, SICK],\n    [0.7, SUSCEPTIBLE],\n  ],\n  [RECOVERED]: [\n    [1, RECOVERED],\n  ],\n  [SICK]: [\n    [1, SICK],\n  ],\n  [DEAD]: [\n    [1, DEAD],\n  ],\n};\n\nexport function getNextMarkovStateForAgent(agent, transitionMap) {\n  const [agentLocation] = agent.location.split('-');\n\n  if (agentLocation === 'house' && Math.random() < 0.9) {\n    return STAY;\n  }\n\n  const map = transitionMap[agentLocation];\n\n  return randomChoice(map);\n}\n\nexport function applySIRModel(nodes, edges) {\n  for (const node of nodes) {\n    if (node.type !== 'agent') {\n      continue;\n    }\n\n    const location = nodes.find(({ id }) => node.location === id);\n    const fellows = edges\n      .filter(({ target }) => target.id === location.id)\n      .map(({ source }) => source);\n\n    fellows.forEach(\n      (fellow) => {\n        if (fellow.id === node.id) {\n          return;\n        }\n\n        if (node.state === SICK) {\n          fellow.state = weightedRandom(DISEASE_SPREAD_TRANSITION[fellow.state]);\n        }\n\n        fellow.state = weightedRandom(SIR_TRANSITION_STATE[fellow.state]);\n      }\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}